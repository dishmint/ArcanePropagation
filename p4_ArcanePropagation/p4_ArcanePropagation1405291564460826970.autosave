// FILE: ArcanePropagation
// AUTHOR: Faizon Zaman

PShader blueline;
PGraphics pg,canvas;

PImage simg;
float[][][] xmg;

float maxsum;
int matrixsize;

void setup(){
	size(800,800, P3D);
	surface.setTitle("Arcane Propagations");
	pixelDensity(1);
	pg = createGraphics(800,800, P2D);
	pg.noSmooth();
	
	
	// simg = loadImage("./imgs/buff_skate.JPG");
	// simg = loadImage("./imgs/face.png");
	// simg = loadImage("./imgs/p5sketch1.jpg");
	// simg = loadImage("./imgs/fezHassan.JPG");
	// simg = loadImage("./imgs/buildings.jpg");
	// simg = loadImage("./imgs/clouds.jpg");
	 //simg = loadImage("./imgs/nasa.jpg");
	simg = randomImage(10,10);
	
	
	// img.filter(GRAY);
	simg.resize(width,0);
	
	// maxsum = 255. * 3.;
  matrixsize = 3;
	xmg = loadxm(simg, matrixsize);
	
	
	
	blueline = loadShader("blueline.glsl");
	blueline.set("resolution", float(pg.width), float(pg.height));
	blueline.set("tex0", simg);
	blueline.set("aspect", float(simg.width)/float(simg.height));

	// frameRate(1.);
}

void draw(){
	
	pg.beginDraw();
	pg.background(0);
	pg.shader(blueline);
	pg.rect(0, 0, pg.width, pg.height);
	pg.endDraw();
	
	kernelp(simg,xmg);
	
	blueline.set("tex0", simg);
	
	image(pg, 0, 0, width, height);
}


float[][] loadkernel(int x, int y, int dim, PImage img){
  float[][] kern = new float[dim][dim];
  img.loadPixels();
  int offset = dim / 2;
  for (int i = 0; i < dim; i++){
    for (int j= 0; j < dim; j++){

      int xloc = x+i-offset;
      int yloc = y+j-offset;
      int loc = xloc + img.width*yloc;
      
      loc = constrain(loc,0,img.pixels.length-1);
      float gs = (
        0.2989 *   red(img.pixels[loc]) +
        0.5870 * green(img.pixels[loc]) +
        0.1140 *  blue(img.pixels[loc])
        ) / 255;

      kern[i][j] = (gs);
    }
  }
  img.updatePixels();
  return kern;
}

float[][][] loadxm(PImage img) {
	float[][][] xms = new float[int(img.width * img.height)][matrixsize][matrixsize];
  println("xms length: ",xms.length);
  println("xms [] length: ",xms[0].length);
  float[][] kernel = new float[matrixsize][matrixsize];
	img.loadPixels();
	for (int i = 0; i < img.width; i++){
		for (int j = 0; j < img.height; j++){
			kernel = loadkernel(i,j, matrixsize, img);
			int index = (i + j * img.width);
      println("index",index);
			xms[index] = kernel;
      print("A:", xms[index][0], "B:", xms[index][1], "C:",xms[index][2]);
		}
	}
	img.updatePixels();
	return xms;
}

void kernelp(PImage img, float[][][] ximage) {
	img.loadPixels();
	for (int i = 0; i < img.width; i++){
		for (int j = 0; j < img.height; j++){
			color c = convolution(i,j, matrixsize, img, ximage);
			int index = (i + j * img.width);
			img.pixels[index] = c;
		}
	}
	img.updatePixels();
}


// https://processing.org/examples/convolution.html
// Adjusted slightly for the purposes of this sketch
color convolution(int x, int y, int matrixsize, PImage img, float[][][] ximg)
{
	float rtotal = 0.0;
	float gtotal = 0.0;
	float btotal = 0.0;
	int offset = matrixsize / 2;
	for (int i = 0; i < matrixsize; i++){
		for (int j= 0; j < matrixsize; j++){

			int xloc = x+i-offset;
			int yloc = y+j-offset;
			int loc = xloc + img.width*yloc;
      println(loc);
			loc = constrain(loc,0,img.pixels.length-1);
      println(loc);
      println(img.pixels[loc]);
      println(ximg[loc][i]);
			rtotal += (  red(img.pixels[loc]) * ximg[loc][i][j]);
			gtotal += (green(img.pixels[loc]) * ximg[loc][i][j]);
			btotal += ( blue(img.pixels[loc]) * ximg[loc][i][j]);
		}
	}
	
	return color(rtotal, gtotal, btotal);
}

PImage randomImage(int w, int h){
	PImage rimg = createImage(w,h, ARGB);
	rimg.loadPixels();
	for (int i = 0; i < rimg.width; i++){
		for (int j = 0; j < rimg.height; j++){
			color c = color(random(255.));
			int index = (i + j * rimg.width);
			rimg.pixels[index] = c;
		}
	}
	rimg.updatePixels();
	return rimg;
}
